# Speeduino ECU 代码解析

## 1. 传感器 → 全局状态 (currentStatus)

### 函数链
- `readMAP()` → `currentStatus.MAP`
- `readTPS()` → `currentStatus.TPS`
- `readCLT()` → `currentStatus.coolant`

```cpp
// 参数依赖：无显式输入，通过 ADC 原始值计算
// 输出：更新全局结构体 currentStatus 对应字段
void readMAP() {
  currentStatus.MAP = analogRead(pinMAP) * configPage2.mapCalibration;
}
```

## 2. 全局状态 → 燃油控制

### 函数链
- `getVE1()` → `PW()` → `setFuelSchedule()`

### 输入参数依赖：
#### `getVE1()` 依赖：
- `currentStatus.MAP`（或 `currentStatus.TPS`，由 `configPage2.fuelAlgorithm` 决定）
- `currentStatus.RPM`（来自曲轴中断计算的全局变量）

#### `PW()` 依赖：
- `VE`（来自 `getVE1()` 返回值）
- `currentStatus.MAP`（二次使用）
- `correctionsFuel()` 返回的校正因子（全局状态参与计算）

```cpp
// getVE1() 输出：VE 值（0-255）
byte getVE1() {
  return get3DTableValue(&fuelTable, currentStatus.fuelLoad, currentStatus.RPM);
}

// PW() 输入参数：REQ_FUEL（配置常量）、VE、MAP、校正值等
uint16_t PW(int REQ_FUEL, byte VE, long MAP, uint16_t corrections, int injOpen) {
  return (REQ_FUEL * VE * MAP * corrections / 10000) + injOpen;
}
```

## 3. 全局状态 → 点火控制

### 函数链
- `getAdvance1()` → `calculateIgnitionAngles()` → `setIgnitionSchedule()`

### 输入参数依赖：
#### `getAdvance1()` 依赖：
- `currentStatus.ignLoad`（MAP/TPS，由 `configPage2.ignAlgorithm` 决定）
- `currentStatus.RPM`

#### `calculateIgnitionAngles()` 依赖：
- `currentStatus.dwell`（闭合时间，含启动/运行模式切换）
- `currentStatus.advance`（来自 `getAdvance1()`）

```cpp
// getAdvance1() 输出：点火提前角（单位：度）
byte getAdvance1() {
  return get3DTableValue(&ignitionTable, currentStatus.ignLoad, currentStatus.RPM);
}

// calculateIgnitionAngles() 输入：dwellAngle（闭合时间转换的角度）
void calculateIgnitionAngles(uint16_t dwellAngle) {
  ignition1StartAngle = currentStatus.advance - dwellAngle;
}
```

## 4. 曲轴中断 → 全局时序

### 函数链
- `triggerHandler()` → `currentStatus.RPM / currentStatus.hasSync`

### 中断上下文数据流：
- **输入**：硬件中断信号（曲轴齿脉冲）
- **输出**：
    - `toothLastToothTime`（最后齿时间，用于计算 RPM）
    - `currentStatus.hasSync`（同步标志）

```cpp
// 中断服务函数（无显式参数，直接操作全局变量）
void triggerHandler() {
  uint32_t now = micros();
  uint32_t toothInterval = now - toothLastToothTime;
  toothLastToothTime = now;
  currentStatus.RPM = 60000000UL / (toothInterval * triggerTeeth); // 计算 RPM
  if (isSyncTooth()) currentStatus.hasSync = true; // 同步信号检测
}
```

## 5. 校正逻辑 → 控制参数

### 函数链
- `correctionsFuel()` → `PW()`
- `correctionsIgn()` → `getAdvance1()`

### 校正函数输入：
#### `correctionsFuel()`：
- `currentStatus.coolant`（水温）
- `currentStatus.O2`（氧传感器）

#### `correctionsIgn()`：
- `currentStatus.knock`（爆震信号）
- `currentStatus.IAT`（进气温度）

```cpp
// 返回燃油校正因子（百分比，如 110 表示增加 10%）
uint16_t correctionsFuel() {
  uint16_t correction = 100;
  if (currentStatus.coolant < 80) correction += 20; // 冷启动加浓
  return correction;
}

// 返回点火校正角度（如 -2 表示延迟 2 度）
int8_t correctionsIgn(byte baseAdvance) {
  if (currentStatus.knock > configPage4.knockThreshold) return baseAdvance - 2;
  return baseAdvance;
}
```

## 6. 全局状态 (currentStatus) 关键字段依赖图

```mermaid
graph TD
  A[传感器] --> B[currentStatus.MAP/TPS/CLT/IAT]
  B --> C[getVE1()/getAdvance1()]
  C --> D[PW()/calculateIgnitionAngles()]
  D --> E[setFuelSchedule()/setIgnitionSchedule()]
  E --> F[硬件输出: 喷油器/点火线圈]
  G[曲轴中断] --> H[currentStatus.RPM/hasSync]
  H --> C
  H --> D
```

## 关键依赖总结

1. **传感器 → 全局状态**：所有传感器数据最终写入 `currentStatus`，作为控制逻辑的输入源。
2. **全局状态 → 查表逻辑**：燃油和点火表查询直接依赖 `currentStatus` 中的实时数据。
3. **校正逻辑 → 动态参数**：环境校正（温度、爆震）通过独立函数修改最终控制参数。
4. **中断 → 时序核心**：曲轴中断直接更新 RPM 和同步状态，绕过参数传递，依赖全局变量实现实时性。

通过此分析，可清晰定位数据流动路径，快速理解函数间如何协作实现四冲程控制。

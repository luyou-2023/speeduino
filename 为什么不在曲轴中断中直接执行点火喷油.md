# 为什么不在曲轴中断中直接执行点火/喷油？

## 原因分析

### 中断处理时间限制
曲轴中断（如 60-2 齿盘的 60 齿）触发频率极高（例如 6000 RPM 时，每齿间隔仅约 83μs）。

若在中断中直接计算点火/喷油时间，可能超出中断处理时间窗口，导致后续中断丢失或系统崩溃。

中断处理函数（如 `triggerHandler()`）必须尽可能轻量，仅记录时间和角度，不执行复杂计算。

### 时间精度需求
点火和喷油需要微秒级精度，但实际触发时间可能位于两个曲轴中断之间。

例如：若需要在曲轴角度 30° 点火，但曲轴中断仅在每齿（如 6° 间隔）触发，需通过定时器在精确时间触发。

### 硬件资源限制
Arduino Mega 的硬件定时器数量有限（如 6 个），需通过软件调度管理多个喷油/点火通道。

---

## 喷油与点火的核心代码实现

### 喷油控制流程

#### 喷油脉宽计算
```cpp
// speeduino.ino
currentStatus.PW1 = PW(req_fuel_uS, currentStatus.VE, currentStatus.MAP, currentStatus.corrections, inj_opentime_uS);
```

#### 喷油角度转换
```cpp
// 计算喷油起始角度（基于曲轴角度）
injector1StartAngle = calculateInjectorStartAngle(PWdivTimerPerDegree, channel1InjDegrees, currentStatus.injAngle);
```

#### 喷油调度
```cpp
// 设置喷油定时器（关键函数）
setFuelSchedule(fuelSchedule1, timeOut, (unsigned long)currentStatus.PW1);
```

### 点火控制流程

#### 点火提前角计算
```cpp
// speeduino.ino
currentStatus.advance = getAdvance1(); // 查表获取基础提前角
```

#### 点火角度与闭合时间计算
```cpp
// 计算点火闭合角度（Dwell）和触发时间
calculateIgnitionAngles(timeToAngleDegPerMicroSec(currentStatus.dwell));
```

#### 点火调度
```cpp
// 设置点火定时器（关键函数）
setIgnitionSchedule(ignitionSchedule1, timeOut, currentStatus.dwell + fixedCrankingOverride);
```

---

## 关键代码片段解析

### 曲轴中断处理（仅记录时间）
```cpp
// timers.ino
void triggerHandler() {
  uint32_t now = micros();
  toothLastToothTime = now; // 记录当前齿时间
  calculateToothAngle();     // 更新曲轴角度
  if (isSyncTooth()) currentStatus.hasSync = true; // 同步标记
}
```

### 定时器调度喷油/点火

```cpp
// scheduledIO.ino
void setFuelSchedule(FuelSchedule &schedule, uint32_t timeout, uint16_t duration) {
  // 使用定时器设置喷油触发时间
  timer.setTimer(timeout, []() {
    digitalWrite(pinInjector1, HIGH); // 打开喷油器
  });
  timer.setTimer(timeout + duration, []() {
    digitalWrite(pinInjector1, LOW);  // 关闭喷油器
  });
}

void setIgnitionSchedule(IgnitionSchedule &schedule, uint32_t timeout, uint16_t dwell) {
  // 使用定时器设置点火触发时间
  timer.setTimer(timeout, []() {
    digitalWrite(pinCoil1, HIGH); // 闭合点火线圈（开始充电）
  });
  timer.setTimer(timeout + dwell, []() {
    digitalWrite(pinCoil1, LOW);  // 断开点火线圈（火花触发）
  });
}
```

---

## 设计总结

### 曲轴中断
- 仅负责记录时间基准和更新全局状态（如 RPM、曲轴角度）。

### 定时器调度
- 在 `loop()` 中根据曲轴角度计算未来的触发时间。
- 通过硬件/软件定时器在精确时间触发喷油和点火动作。

### 优势
- 避免中断处理过载，确保曲轴信号不丢失。
- 支持多缸引擎的复杂时序控制（如顺序喷油、分组点火）。

### 代码入口点
- **喷油逻辑**：
  ```
  loop() → PW() → setFuelSchedule()
  ```
- **点火逻辑**：
  ```
  loop() → getAdvance1() → calculateIgnitionAngles() → setIgnitionSchedule()
  ```
- **曲轴中断**：
  ```
  triggerHandler() → 更新 currentStatus.RPM 和 toothLastToothTime
  ```

通过这种设计，Speeduino 在有限的硬件资源下实现了高精度的四冲程引擎控制。

